/*
 * ANTRL (http://www.antlr.org/) grammar for the project language. You will
 * probably want to adapt the file to generate parser for your language of
 * choice and use your own data structures (or define tree parser to traverse
 * the tree generated by ANTLR).
 *
 * Note that this has not been throughly tested, so let us know if there are
 * any problems.
 */

grammar TheLang;

options {
  language= Java;  /* Change this to generate parser for some other language. */
  backtrack = true;
  memoize = true;
  output = AST;
  ASTLabelType = CommonTree;
}

tokens {
  AND = '&';
  OR = '|';
  ASSIGN = ':=';
  SEMI = ';';
  GT = '>';
  GE = '>=';
  LT = '<';
  LE = '<=';
  EQ = '=';
  NEQ = '!=';
  PLUS = '+';
  MINUS = '-';
  MUL = '*';
  DIV = '/';
  NOT = '!';
  LPAREN = '(';
  RPAREN = ')';
  LBRACE = '{';
  RBRACE = '}';
  LBRACKET = '[';
  RBRACKET = ']';
  COLON = ':';
  IF = 'if';
  THEN = 'then';
  ELSE = 'else';
  FI = 'fi';
  WHILE = 'while';
  DO = 'do';
  OD = 'od';
  SKIP = 'skip';
  WRITE = 'write';
  READ = 'read';
  PROGRAM = 'program';
  END = 'end';
  TRUE = 'true';
  FALSE = 'false';
  INT = 'int';
  LOW = 'low';
  HIGH = 'high';
}

aexpr
@init {
    CommonToken start = (CommonToken)input.LT(1);

    Main.buildVertex(start, "aexpr");
}
@after {
    CommonToken end = (CommonToken)input.LT(1);

    Main.assignVertex(end);
}
: aexpr1 (PLUS aexpr1 | MINUS aexpr1)* ;

aexpr1
@init {
    CommonToken start = (CommonToken)input.LT(1);

    Main.buildVertex(start, "aexpr1");
}
@after {
    CommonToken end = (CommonToken)input.LT(1);

    Main.assignVertex(end);
}
: aexpr2 (MUL aexpr2 | DIV aexpr2)* ;

aexpr2
@init {
    CommonToken start = (CommonToken)input.LT(1);

    Main.buildVertex(start, "aexpr2");
}
@after {
    CommonToken end = (CommonToken)input.LT(1);

    Main.assignVertex(end);
}
: MINUS aexpr3
       | aexpr3
       ;

aexpr3
@init {
    CommonToken start = (CommonToken)input.LT(1);

    Main.buildVertex(start, "aexpr3");
}
@after {
    CommonToken end = (CommonToken)input.LT(1);

    Main.assignVertex(end);
}
: IDENTIFIER (LBRACKET aexpr RBRACKET)?
       | INTEGER
       | LPAREN aexpr RPAREN
       ;

bexpr
@init {
    CommonToken start = (CommonToken)input.LT(1);

    Main.buildVertex(start, "bexpr");
}
@after {
    CommonToken end = (CommonToken)input.LT(1);

    Main.assignVertex(end);
}
: bexpr1 (OR bexpr1)*
      ;

bexpr1
@init {
    CommonToken start = (CommonToken)input.LT(1);

    Main.buildVertex(start, "bexpr1");
}
@after {
    CommonToken end = (CommonToken)input.LT(1);

    Main.assignVertex(end);
}
: bexpr2 (AND bexpr2)*
       ;

bexpr2
@init {
    CommonToken start = (CommonToken)input.LT(1);

    Main.buildVertex(start, "bexpr2");
}
@after {
    CommonToken end = (CommonToken)input.LT(1);

    Main.assignVertex(end);
}
: aexpr opr aexpr
       | NOT bexpr
       | TRUE
       | FALSE
       | LPAREN bexpr RPAREN
       ;

opr
@init {
    CommonToken start = (CommonToken)input.LT(1);

    Main.buildVertex(start, "opr");
}
@after {
    CommonToken end = (CommonToken)input.LT(1);

    Main.assignVertex(end);
}
: GT
    | GE
    | LT
    | LE
    | EQ
    | NEQ
    ;

decl
@init {
    CommonToken start = (CommonToken)input.LT(1);

    Main.buildVertex(start, "decl");
}
@after {
    CommonToken end = (CommonToken)input.LT(1);

    Main.assignVertex(end);
}
: level? INT IDENTIFIER (LBRACKET INTEGER RBRACKET)? SEMI ;

level : LOW | HIGH ;

stmt
@after {
    CommonToken end = (CommonToken)input.LT(1);

    Main.assignVertex(end);
}
: assignStmt
     | skipStmt
     | readStmt
     | writeStmt
     | ifStmt
     | whileStmt
     ;

assignStmt
@init {
    CommonToken start = (CommonToken)input.LT(1);

    Main.buildVertex(start, "assign");
}
: IDENTIFIER (LBRACKET aexpr RBRACKET)? ASSIGN aexpr SEMI ;

skipStmt
@init {
    CommonToken start = (CommonToken)input.LT(1);

    Main.buildVertex(start, "skip");
}
: SKIP SEMI ;

readStmt
@init {
    CommonToken start = (CommonToken)input.LT(1);

    Main.buildVertex(start, "read");
}
: READ IDENTIFIER (LBRACKET aexpr RBRACKET)? SEMI ;

writeStmt
@init {
    CommonToken start = (CommonToken)input.LT(1);

    Main.buildVertex(start, "write");
}
: WRITE aexpr SEMI ;

ifStmt
@init {
    CommonToken start = (CommonToken)input.LT(1);

    Main.buildVertex(start, "if");
}
: IF bexpr THEN stmt+ ELSE stmt+ FI ;

whileStmt
@init {
    CommonToken start = (CommonToken)input.LT(1);

    Main.buildVertex(start, "while");
}
: WHILE bexpr DO stmt+ OD ;

program
@init {
    CommonToken start = (CommonToken)input.LT(1);

    Main.buildVertex(start, "program");
}
@after {
    CommonToken end = (CommonToken)input.LT(1);

    Main.assignVertex(end);
}
: PROGRAM decl* stmt+ END -> ^(PROGRAM decl stmt END);


COMMENT : '(*' (options {greedy=false;} : .)* '*)' {$channel=HIDDEN;}
     ;

INTEGER : ('0' | '1'..'9' '0'..'9'*);

IDENTIFIER : LETTER (LETTER|'0'..'9')* ;

fragment
LETTER : 'A'..'Z'
       | 'a'..'z'
       | '_'
       ;

WS : (' '|'\r'|'\t'|'\u000C'|'\n') { skip(); } ;
